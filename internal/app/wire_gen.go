// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"eticket-api/config"
	"eticket-api/internal/client"
	"eticket-api/internal/common/db"
	"eticket-api/internal/common/httpclient"
	"eticket-api/internal/common/logger"
	"eticket-api/internal/common/mailer"
	"eticket-api/internal/common/token"
	"eticket-api/internal/common/transact"
	"eticket-api/internal/common/validator"
	"eticket-api/internal/delivery/http"
	"eticket-api/internal/domain"
	"eticket-api/internal/job"
	"eticket-api/internal/repository"
	"eticket-api/internal/usecase"
	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
	"log"
	"time"
)

// Injectors from server.go:

// Wire injector
func New(cfg *config.Config) (*Server, error) {
	gormDB, err := db.NewPostgres(cfg)
	if err != nil {
		return nil, err
	}
	jwt := token.NewJWT(cfg)
	string2 := _wireStringValue
	loggerLogger := logger.NewLogrus(string2)
	validatorValidator := validator.NewValidator(cfg)
	gotann := transact.NewTransactionManager(gormDB)
	quotaRepository := repository.NewQuotaRepository(gormDB)
	quotaUsecase := usecase.NewQuotaUsecase(gotann, quotaRepository)
	refreshTokenRepository := repository.NewRefreshTokenRepository(gormDB)
	userRepository := repository.NewUserRepository(gormDB)
	smtp := mailer.NewSMTP(cfg)
	authUsecase := usecase.NewAuthUsecase(gotann, refreshTokenRepository, userRepository, smtp, jwt)
	bookingRepository := repository.NewBookingRepository(gormDB)
	bookingUsecase := usecase.NewBookingUsecase(gotann, bookingRepository)
	classRepository := repository.NewClassRepository(gormDB)
	classUsecase := usecase.NewClassUsecase(gotann, classRepository)
	harborRepository := repository.NewHarborRepository(gormDB)
	harborUsecase := usecase.NewHarborUsecase(gotann, harborRepository)
	roleRepository := repository.NewRoleRepository(gormDB)
	roleUsecase := usecase.NewRoleUsecase(gotann, roleRepository)
	claimSessionRepository := repository.NewClaimSessionRepository(gormDB)
	shipRepository := repository.NewShipRepository(gormDB)
	scheduleRepository := repository.NewScheduleRepository(gormDB)
	ticketRepository := repository.NewTicketRepository(gormDB)
	scheduleUsecase := usecase.NewScheduleUsecase(gotann, claimSessionRepository, classRepository, shipRepository, scheduleRepository, ticketRepository)
	shipUsecase := usecase.NewShipUsecase(gotann, shipRepository)
	ticketUsecase := usecase.NewTicketUsecase(gotann, ticketRepository, scheduleRepository, quotaRepository)
	userUsecase := usecase.NewUserUsecase(gotann, userRepository)
	httpclientHTTP := httpclient.NewHTTPClient(cfg)
	tripayClient := client.NewTripayClient(httpclientHTTP, cfg)
	paymentUsecase := usecase.NewPaymentUsecase(gotann, tripayClient, bookingRepository, ticketRepository, quotaRepository, smtp)
	claimItemRepository := repository.NewClaimItemRepository(gormDB)
	claimSessionUsecase := usecase.NewClaimSessionUsecase(gotann, claimSessionRepository, claimItemRepository, ticketRepository, scheduleRepository, bookingRepository, quotaRepository, tripayClient, smtp)
	router := http.NewRouter(jwt, loggerLogger, validatorValidator, quotaUsecase, authUsecase, bookingUsecase, classUsecase, harborUsecase, roleUsecase, scheduleUsecase, shipUsecase, ticketUsecase, userUsecase, paymentUsecase, claimSessionUsecase)
	claimSessionJob := job.NewClaimSessionJob(loggerLogger, claimSessionUsecase)
	server, err := NewServer(gormDB, router, claimSessionJob)
	if err != nil {
		return nil, err
	}
	return server, nil
}

var (
	_wireStringValue = "eticket-api"
)

// server.go:

type Server struct {
	app *gin.Engine
}

// NewServer menerima semua dependency yang dibutuhkan, Wire akan mengisi otomatis
func NewServer(db2 *gorm.DB,
	router *http.Router,
	claimSessionJob *job.ClaimSessionJob,
) (*Server, error) {
	gin.SetMode(gin.DebugMode)
	app := gin.Default()

	if err := db2.AutoMigrate(
		&domain.Role{},
		&domain.User{},
		&domain.Ship{},
		&domain.Harbor{},
		&domain.Class{},
		&domain.Schedule{},
		&domain.Booking{},
		&domain.Quota{},
		&domain.ClaimSession{},
		&domain.ClaimItem{},
		&domain.Ticket{},
		&domain.RefreshToken{},
		&domain.PasswordReset{},
	); err != nil {
		log.Fatalf("Failed to migrate database: %v", err)
	}

	app.Use(cors.New(cors.Config{
		AllowOriginFunc: func(origin string) bool {
			allowed := map[string]bool{
				"http://localhost:3000":          true,
				"https://tiket-hebat.vercel.app": true,
				"https://www.tikethebat.live":    true,
				"https://tripay.co.id/":          true,
			}
			return allowed[origin]
		},
		AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	api := app.Group("/api")

	router.RegisterMetrics(api)
	router.RegisterV1(api.Group("/v1"))
	router.RegisterV2(api.Group("/v2"))
	go claimSessionJob.CleanExpiredClaimSession()

	return &Server{app: app}, nil
}

func (server Server) App() *gin.Engine {
	return server.app
}
